\documentclass[twocolumn]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{algorithmic}
\usepackage{enumitem}
\setlist{nolistsep}


\author{
Nombre:....................................... \\
    Departamento de Informática y Sistemas \\
    Universidad EAFIT \\
}
\title{
    Estructuras de Datos 1 - ST0245 \\
    Examen Parcial 1 - 032 - Martes
}
\date{
    Septiembre 05 de 2017
}

\begin{document}
\vspace{-5cm}
\maketitle


\section*{Criterios de calificación}

{\small
\begin{itemize}
\item Selección múltiple con única respuesta
\begin{itemize}
\item Respuesta correcta: 100\%
\item Respuesta incorrecta: 0\%
\end{itemize}

\item Completar código
\begin{itemize}
\item Respuesta correcta 100\%
\item Respuesta incorrecta o vacía 0\%\\
\end{itemize}
\end{itemize}


\textbf{NOTAS IMPORTANTES:}
\begin{itemize}
	\item Responda en la hoja de PREGUNTAS
	\item Marque la hoja de PREGUNTAS
\end{itemize}
}

\section{Notación O grande 10\%}
Después de hacer un análisis de complejidad de un algoritmo \texttt{A(n)}, obtuvimos que ejecuta, en el peor caso pasos, $T(n) = 2^n + n^2 + 7n$. ¿Cuál es el orden asintótico del algoritmo? \\

O(\_\_\_\_\_\_\_\_\_\_\_\ )

%O(2^n)

\section{Listas 10\%}

En algoritmiandia existe un método \texttt{busqueda} que busca un número en un arreglo de números, con una complejidad de $O(log \ n)$, donde $n$ es el tamaño del arreglo.
Existe otro método, llamado \texttt{método1}, que tiene dos ciclos anidados y dentro del ciclo interno se llama al método \texttt{busqueda} con cada uno de los elementos
de una matriz. Si un elemento de la matriz, es decir \texttt{matriz[i][j]}, se encuentra en el arreglo \texttt{sec}, el elemento  se añade al final de una lista doblemente enlazada (\texttt{LinkedList}).

{\footnotesize
\begin{verbatim}
public List<Integer> metodo1(int[][] matriz){
 LinkedList<Integer> lista = new LinkedList<>();
 for(int i = 0; i < matriz.length; ++i){
   for(int j = 0; j < matriz[0].length; ++j){
     boolean esta = busqueda(sec, matriz[i][j]);
     if(esta)
       lista.add(matriz[i][j]);
   }
 }
 return lista;
}
\end{verbatim}
}

¿Cuál es la complejidad asintótica del método \texttt{metodo1} asumiendo que la matriz es de $n \times m$
y el arreglo \texttt{sec} es de tamaño $n$? \\

O(\_\_\_\_\_\_\_\_\_\_\_\ )

%O(n*m*log n)

\section{Listas 10\%}
¿Cuál operación tiene una mayor complejidad asintótica, para el peor de los casos, 
en un lista simplemente enlazada?\\

{\small
\begin{enumerate}[label=\Alph*]
	\item Insertar un elemento en la mitad de la lista
	\item Borrar el elemento que está en la mitad de la lista
	\item Obtener el elemento que está en la mitad de la lista
	\item Las tres tienen la misma complejidad asintótica
\end{enumerate}
}

%Todas son iguales O(n)

\section{Complejidad 10\%}

El siguiente algoritmo calcula la suma de los elementos de una matriz cuadrada de tamaño $n$. 

{\small
\begin{verbatim}
public int suma(int[][] m) { 
     int sum = 0; 
     for(int i=0; i < m.length; i++){
          for(int j=0; j < m.length; j++){
                sum = sum + m[i][j]; }}
    return sum;}
\end{verbatim}
}

¿Cuál es su complejidad asintótica en el peor de los casos?\\

O(\_\_\_\_\_\_\_\_\_\_\_\ )

%Es O(n^2)

\section{Complejidad 20\%}

El siguiente algoritmo cuenta del $n$ al $1$.

{\small
\begin{verbatim}
public void imprimir(int n) {
  if (n == 1)  println(1);
  else {  println(n);
          imprimir(n-1);   }}
\end{verbatim}
}

(10 \%) ¿Cuál es el número de pasos que ejecuta para el peor de los casos?\\

$T(n) =$ \_\_\_\_\_\_\_\_\_\_\_\ \\

(10 \%) ¿Cuál es la complejidad asintótica en el peor de los casos?\\

O(\_\_\_\_\_\_\_\_\_\_\_\ )





\section{Recursion 40\%}

Hay un tablero de $2 \times n$ cuadrados y usted necesita saber de cuantas maneras se puede llenar el tablero usando rectángulos de $1 \times 2$. Se ha propuesto el siguiente algoritmo 
recursivo


\begin{verbatim}
 1 public int formas(int n){
 2   if (n == 0){
 3       return 1;
 4   }
 5   if(n == 1 || n == 2)   __________;
 6   return formas(____) +                                  
 7          formas(____);
 8 }
\end{verbatim}



Complete las líneas faltantes.\\


 (10\%) Linea 5. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ \\

 (10\%) Linea 6. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ \\

(10\%) Linea 7. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ \\


(10 \%) ¿Cuántas instrucciones ejecuta el algoritmo en el peor de los casos? \\

\begin{enumerate}[label=\Alph*.]
\item $T(n) = T(n-1) + C$
\item $T(n) = T(n-1)+T(n-2) + C$
\item $T(n) = T(n/2) + C$
\item $T(n) = T(n+1) + C$\\
\end{enumerate}

\textbf{Pista:} Considere llenar un tablero de $2 \times n$. Si le quitamos la primera baldosa tenemos un tablero de $2 \times (n – 1)$ (usando recursión). Si le quitamos $2$ baldosas queda un tablero de $2 \times (n – 2)$. Haga el dibujo. ¿Se le pueden quitar 3 baldosas, o con lo anterior ya puedo formar el de $2 \times (n – 3)$? \\


\end{document}