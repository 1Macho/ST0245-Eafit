\documentclass[twocolumn]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{algorithmic}
\usepackage{enumitem}
\setlist{nolistsep}


\author{
Nombre:....................................... \\
    Departamento de Informática y Sistemas \\
    Universidad EAFIT \\
}
\title{
    Estructuras de Datos 1 - ST0245 \\
    Examen Parcial 1
}
\date{
    Marzo 14, 2017
}

\begin{document}
\vspace{-5cm}
\maketitle


\section*{Criterios de calificación}

\textbf{NOTAS IMPORTANTES:}
\begin{itemize}
	\item Responda en la hoja de PREGUNTAS
	\item Marque la hoja de PREGUNTAS
\end{itemize}

\begin{itemize}
\item Selección múltiple con única respuesta
\begin{itemize}
\item Respuesta correcta: 100\%
\item Respuesta incorrecta: 0\%
\end{itemize}

\item Completar código
\begin{itemize}
\item Respuesta correcta 100\%
\item Respuesta incorrecta o vacía 0\%
\end{itemize}
\end{itemize}




\section{Notación O grande 10\%}
Supongamos que $P(n,m)$ es una función cuya complejidad asintótica es 
$O (n \times m)$ y H(n,m) es otra función cuya complejidad asintótica es $O(m * A (n,m))$, donde $A(n,m)$ es otra función. ¿Cuál de las siguientes funciones, definitivamente, \textbf{NO} podría ser la complejidad asintótica de $A(n,m)$ si tenemos en cuenta que $P(n,m) > H(n,m)$ para todo $n$ y para todo $m$?

\begin{enumerate}[label=\Alph*]
	\item $O (log\ n)$
	\item $O (\sqrt{n})$
	\item $O (n + m)$
	\item $O (1 )$
\end{enumerate}

%la C, O(n+m)

\section{Complejidad 10\%}
Dayla sabe que la complejidad asintótica de la función \texttt{P(n)} es $O (\sqrt{n})$. Ayúdale a Dayla a sacar la complejidad asintótica para la función \texttt{mistery(n,m)}.

{\small
\begin{verbatim}
void mistery(int n, int m) 
  for(int i = 0; i < m; ++i) 
    boolean can = P(n);
    if(can) 
      for(int i = 1; i * i <= n; i++) 
        //Hacer algo en O(1)
    else 
      for(int i = 1; i <= n; i++) 
        //Hacer algo en O(1)	
\end{verbatim}
}

\noindent
La complejidad de \texttt{mistery(n,m)} es:

\begin{enumerate}[label=\Alph*]
	\item $O (m + n)$
	\item $O (m \times n \times \sqrt{n})$
	\item $O (m + n + \sqrt{n})$
	\item $O (m \times n )$
\end{enumerate} 

% la D, O(m * n)

\section{Listas 10\%}
¿Cuál operación tiene una mayor complejidad asintótica, para el peor de los casos, 
en un lista simplemente enlazada?

\begin{enumerate}[label=\Alph*]
	\item Buscar un dato cualquiera en la lista
	\item Insertar un elemento cualquiera en la lista
	\item Las dos tienen la misma complejidad asintótica
\end{enumerate}

%la C, tienen la misma

\section{Complejidad 10\%}
Sabemos que \texttt{P(n)} ejecuta $n^3 + n$ pasos y que \texttt{D(n)} ejecuta $n + 7$ pasos. ¿Cuál es la complejidad asintótica, en el peor de los casos, de la función \texttt{B(n)}?

{\small
\begin{verbatim}
public int B(int n)
  int getP = P(n);
  int ni = 0;
  for(int i = 0; i < n; ++i)
    if(D(i) > 100){
      ni++;
  int nj = getP + D(n) * ni;
  return nj;
\end{verbatim}
}

\begin{enumerate}[label=\Alph*]
	\item $O (n^4)$
	\item $O (n^3)$
	\item $O (n^2)$
	\item $O (2^n)$
\end{enumerate} 

%B, es n cubo

\section{Colas 10\%}
¿Cuál es la complejidad asintótica, para el peor de los casos, de la función \texttt{procesarCola(q, n)}?

{\small
\begin{verbatim}
public void procesarCola(Queue q, int n)
  for (int i = 0; i < n; i++)
     for(int j = 0; j < n; j++)
        q.add(j);
        //Hacer algo en O(1)     
\end{verbatim}
}

\begin{enumerate}[label=\Alph*]
	\item $O (n)$
	\item $O (|q|^2)$, $|q|$ es el número de elementos de \texttt{q}
	\item $O (n^2)$
	\item $O (2^n)$\\
\end{enumerate}

%C es O(n^2)
En Java, el método \texttt{add} agrega un elemento
 al comienzo de una cola.

\section{Recursion 10\%}
Pepito escribió un algoritmo que, dado un arreglo de enteros, decide si es posible escoger un subconjunto de esos enteros, de tal forma
que la suma de los elementos de ese subconjunto sea igual a \texttt{target}. El parámetro \texttt{start} funciona como un contador y representa un índice en el arreglo de números \texttt{nums}.

{\small
\begin{verbatim}
01 public boolean SumaGrupo(int start, 
                     int[] nums, int target) {
02  if (start >= nums.length) return target == 0;
03  return SumaGrupo(start + 1, nums, 
                            target - nums[start])
04         || SumaGrupo(____,___,___);
05 }
\end{verbatim}
} 

¿Qué parámetros colocaría en el llamado recursivo de la línea 4 para que el programa funcione?
	\\
	\\
	\_\_\_\_\_\_\_\_\_\_\_\_\_\_, \_\_\_\_\_\_\_\_\_\_\_\_\_, \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

% start + 1, nums, target

\section{Colas 40\%}
{\small
En el juego de \textit{hot potato} (conocido en Colombia como \textit{Tingo, Tingo, Tango}), los niños
hacen un círculo y pasan al vecino de la derecha, un elemento,
 tan rápido como puedan. En un cierto punto del juego,
 se detiene el paso del elemento. El niño que queda con el
 elemento, sale del círculo. El juego continúa
 hasta que sólo quede un niño.

 Este problema se puede simular usando una cola. El algoritmo
 tiene dos entradas: Una cola \texttt{q}  con los nombres de los niños y una constante entera \texttt{num}. El algoritmo retorna el nombre de la última persona que queda en el juego, después de pasar la pelota, en cada ronda, \texttt{num} veces. Como un ejemplo, para el círculo de niños \textit{[Bill, David, Susan, Jane, Kent, Brad]},
donde \textit{Bill} es el primer niño, \textit{Brad} el último,
y \texttt{num} es igual a 7, la respuesta es \textit{Susan}.


 En Java, el método \texttt{add} agrega un elemento
 al comienzo de una cola, y el método \texttt{remove} retira un elemento del final de una cola y retorna el elemento.
}

{\small
\begin{verbatim}
01 String hotPotato(Queue<String> q, int num)
02   while (____________)
03      for (int i = 1; i ____ num; i++)
04         q.add(_________);
05      q.remove();
06   return ___________;
\end{verbatim}
}

% 1 public String hotPotato(Queue q, int num)
% 2   while (q.size() > 1)
% 3      for (int i = 1; i <= num; i++)
% 4         q.add(q.remove());
% 5      q.remove();
% 6   return q.remove();

{\small
A continuación, complete los espacios restantes del código anterior:
}


\begin{enumerate}[label=\Alph*]
	\item (10 \%) Complete el espacio de la línea 02

	\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

	\item (10 \%) Complete el espacio de la línea 03

	\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

	\item (10 \%) Complete el espacio de la línea 04

	\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

	\item (10 \%) Complete el espacio de la línea 06	

	\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\end{enumerate} 


% \section*{Firma}
% {\footnotesize 
% Al firmar afirmo que lo que entrego en este examen es fruto de mi trabajo individual.
% No he recibido ayuda indebida de parte de otra persona. 
% \\

% -------------------------------  \ \ \ \ \ \      ----------------------
              
% Firma\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ Fecha 
% }


\end{document}